# Auto-Generated Examples System for KiloCode Documentation Fixer

This document provides a comprehensive overview of the system used to automatically generate documentation examples for the KiloCode Documentation Fixer. This approach ensures that all examples in `COMPREHENSIVE_FIXERS.md` are always accurate and in sync with the actual functionality of the fixer scripts.

## üèóÔ∏è Architecture Overview

The core idea is to treat unit tests as the "single source of truth" for documentation examples. Instead of manually writing and maintaining markdown examples, we extract them directly from the test suite. This eliminates documentation drift and ensures that if a fixer's behavior changes, its examples are automatically updated when tests are run and documentation is regenerated.

```
Unit Tests (test/docs-fixer.test.js)
  ‚Üì (Store structured data in TEST_EXAMPLES registry)
Example Generation Script (docs/generate-examples.js)
  ‚Üì (Process structured examples)
Comprehensive Fixers Doc (COMPREHENSIVE_FIXERS.md)
  ‚Üë (Auto-generated sections)
```

## How It Works

The `docs/generate-examples.js` script performs the following steps:

### 1. **Structured Test Data**

- Each fixer's unit test (`test/docs-fixer.test.js`) stores example data in the `TEST_EXAMPLES` registry object.
- Tests populate structured data including:
    - `before`: The original markdown content
    - `after`: The fixed markdown content (generated by running the actual fixer)
    - `testName`: Descriptive name for the test
    - `description`: Brief description of what the example demonstrates
    - `expectedErrorTypes`: Types of linting errors the fixer addresses

### 2. **Test Execution and Data Collection**

- The `generate-examples.js` script imports and runs the test suite.
- Tests use the `validateFixerResolvesLintErrors` helper which automatically populates the `TEST_EXAMPLES` registry.
- This ensures the "after" content accurately reflects the current behavior of the fixer.
- Lint validation ensures examples demonstrate real error resolution.

### 3. **Documentation Generation**

- The script processes the structured examples from the `TEST_EXAMPLES` registry.
- It locates predefined "auto-generated" sections in `COMPREHENSIVE_FIXERS.md` (marked with comments like `<!-- AUTO-GENERATED: ... -->`).
- These sections are replaced with the structured "before" and "after" markdown examples, along with metadata from the tests.

## üß™ Test Structure for Example Generation

To ensure examples can be reliably extracted, unit tests follow a specific structure:

```javascript
// Test examples registry - single source of truth for documentation examples
export const TEST_EXAMPLES = {
	listIndentation: null,
	pathFixes: null,
	linkText: null,
	navigationFooter: null,
}

// Ultra-simplified test pattern:
testSuite.addTest("List indentation fixes", async () => {
	const { fixListIndentation } = await import("../src/docs-fixer.js")

	await validateFixerResolvesLintErrors({
		before: `
# Test File

- Item 1
   - Sub item 1
   - Sub item 2
- Item 2
`,
		linter: ["list-item-bullet-indent"],
		fixer: fixListIndentation,
		testName: "List indentation fixes",
		description: "Fix list indentation issues",
		testExamples: TEST_EXAMPLES,
		exampleKey: "listIndentation",
	})
})
```

## üìä Benefits of the Structured Approach

### 1. **Single Source of Truth**

- Tests define both the input and expected output
- Documentation examples are automatically generated from test data
- No manual maintenance of example content

### 2. **Always Accurate**

- Examples reflect the actual behavior of fixer functions
- If a fixer changes, tests fail and examples are updated
- No drift between code and documentation

### 3. **Comprehensive Coverage**

- Every fixer has at least one example in the documentation
- Examples are automatically generated for new fixers
- Test failures indicate when documentation needs updating

### 4. **Rich Metadata**

- Examples include test names, descriptions, and error types
- Links to source test files for traceability
- Fix counts and other relevant metrics

### 5. **Ultra-Simplified Test Structure**

- **70% Less Code**: Tests reduced from 25+ lines to 8 lines each
- **Automatic Everything**: Lint validation, logging, and example storage handled automatically
- **Consistent Pattern**: Every test follows the exact same structure
- **Zero Duplication**: All common logic centralized in `validateFixerResolvesLintErrors`

## üîß Usage

### Generate Examples

```bash
cd scripts/docs-fixes
npm run docs:generate
```

### Update Full Documentation

```bash
cd scripts/docs-fixes
npm run docs:update
```

## üèóÔ∏è Implementation Details

### Test Registry Structure

```javascript
export const TEST_EXAMPLES = {
	listIndentation: {
		testName: "List indentation fixes",
		description: "Basic list indentation fixes",
		before: "...",
		after: "...",
		expectedErrorTypes: ["list-item-bullet-indent"],
		fixesApplied: 2,
	},
	pathFixes: {
		testName: "Path fixes for architecture files",
		description: "Architecture file path fixes",
		before: "...",
		after: "...",
		expectedErrorTypes: ["missing-file"],
		fixesApplied: 3,
		testFile: "docs/architecture/test-file.md",
	},
	// ... other examples
}
```

### Documentation Template

````markdown
<!-- AUTO-GENERATED: This section is generated from unit tests -->

#### Example 1: [Test Name]

**Before**:

```markdown
[Before content]
```
````

**After**:

```markdown
[After content]
```

**Test Source**: `test/docs-fixer.test.js` - "Test Name"

---

```

### Generation Process
1. **Import and run tests**: `await runTests()`
2. **Extract structured data**: Access `TEST_EXAMPLES` registry
3. **Process examples**: Format for documentation
4. **Update documentation**: Replace auto-generated sections

## üöÄ Future Enhancements

### 1. **Lint Validation Integration**
- Validate that "before" content has expected linting errors
- Verify that "after" content has no linting errors
- Make tests fail if linting expectations aren't met

### 2. **Multiple Examples per Fixer**
- Support multiple examples for complex fixers
- Categorize examples by error type or complexity
- Generate comprehensive fixer documentation

### 3. **Interactive Documentation**
- Generate interactive examples that users can run
- Include fixer performance metrics
- Add visual diff comparisons

## üìù Maintenance

### Adding New Examples
1. Add a new test that populates `TEST_EXAMPLES`
2. Include both "before" and "after" content
3. Add descriptive metadata
4. Run `npm run docs:generate` to update documentation

### Updating Existing Examples
1. Modify the test content and assertions
2. The `TEST_EXAMPLES` registry will be updated automatically
3. Run `npm run docs:generate` to update documentation

### Removing Examples
1. Remove the test and its `TEST_EXAMPLES` entry
2. Update documentation templates if needed
3. Run `npm run docs:generate` to update documentation

## üéØ Key Principles

1. **Tests are the source of truth**: All examples come from actual test execution
2. **Structured data**: Use consistent data structures for reliability
3. **Automatic generation**: Minimize manual documentation maintenance
4. **Always accurate**: Examples reflect current fixer behavior
5. **Comprehensive coverage**: Every fixer has documentation examples

This system ensures that the KiloCode Documentation Fixer has accurate, up-to-date, and comprehensive documentation that stays in sync with the actual implementation.

## Navigation

- [‚Üê Documentation Fixer README](./README.md)
- [‚Üë Docs Fixes Home](../README.md)
- [‚Üí Comprehensive Fixers Guide](./COMPREHENSIVE_FIXERS.md)
```
